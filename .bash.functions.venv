#-*-sh-*-

# create and start a new virtualenv:
# depends on existance of $PYTHON2 and $PYTHON3, set in .bashrc.local
# Can't just use `which python2`, because that could be set by virtual env
function create_venv() {
    venv_name=$1
    if [ -z "$venv_name" ]; then
	echo missing arg: virtual env name
	return
    fi

    py_vers=${2-py2}
    case ${py_vers} in
	py2)
	    python_exe=$PYTHON2
	    ;;
	py3)
	    python_exe=$PYTHON3
	    ;;
	*)
	    echo unknown python: $py_vers
	    return
	    ;;
    esac
    

    if [ -d ${VENVS_DIR}/${venv_name} ]; then
	# if [ "${force}" = "-f" ]; then # dumb way of handling opts
	#     rm_venv $1
	# else
	echo virtualenv ${venv_name} already exists
	return
	# fi
    fi
    

    pushd $VENVS_DIR
    virtualenv --python=${python_exe} ${venv_name}
    venv ${venv_name}	     # see above
    my_activate $venv_name   # this effectively starts the virtual_env

    pip install --upgrade pip
    pip install --upgrade wheel
    pip install --upgrade ipython
    pip install --upgrade pbr
    popd
}
